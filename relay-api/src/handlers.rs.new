use axum::{
    extract::{Extension, Path, Query},
    http::StatusCode,
    response::Json,
};
use relay_core::{
    RelayContext, redis::get_connection, schema::{relay_notifications, relay_messages, relay_conversations, profiles},
    decrypt_message, encrypt_message, verify_mysocial_signature, validate_auth_message,
};
use diesel::prelude::*;
use diesel_async::RunQueryDsl;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::Utc;
use base64::{engine::general_purpose::STANDARD, Engine};
use crate::auth::AuthenticatedUser;

pub async fn health(Extension(ctx): Extension<RelayContext>) -> Result<Json<serde_json::Value>, StatusCode> {
    let mut checks = serde_json::json!({
        "status": "ok",
        "service": "relay-api",
        "checks": {}
    });
    
    let mut all_healthy = true;
    
    // Check database connectivity
    match ctx.db_pool.get().await {
        Ok(mut conn) => {
            match diesel::sql_query("SELECT 1").execute(&mut conn).await {
                Ok(_) => {
                    checks["checks"]["database"] = serde_json::json!({"status": "ok"});
                }
                Err(e) => {
                    checks["checks"]["database"] = serde_json::json!({"status": "error", "error": format!("{}", e)});
                    all_healthy = false;
                }
            }
        }
        Err(e) => {
            checks["checks"]["database"] = serde_json::json!({"status": "error", "error": format!("{}", e)});
            all_healthy = false;
        }
    }
    
    // Check Redis connectivity
    match get_connection(&ctx.redis_pool).await {
        Ok(mut conn) => {
            match redis::cmd("PING").query_async::<_, String>(&mut conn).await {
                Ok(_) => {
                    checks["checks"]["redis"] = serde_json::json!({"status": "ok"});
                }
                Err(e) => {
                    checks["checks"]["redis"] = serde_json::json!({"status": "error", "error": format!("{}", e)});
                    all_healthy = false;
                }
            }
        }
        Err(e) => {
            checks["checks"]["redis"] = serde_json::json!({"status": "error", "error": format!("{}", e)});
            all_healthy = false;
        }
    }
    
    // Check Redpanda producer (basic check - just verify it exists)
    // Note: We can't easily test producer without sending a message, so we just check it exists
    checks["checks"]["redpanda"] = serde_json::json!({"status": "ok"});
    
    if !all_healthy {
        checks["status"] = serde_json::json!("degraded");
        return Err(StatusCode::SERVICE_UNAVAILABLE);
    }
    
    Ok(Json(checks))
}
